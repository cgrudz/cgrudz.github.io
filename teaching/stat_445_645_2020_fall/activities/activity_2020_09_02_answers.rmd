# Activity 09/02/2020

## STAT 445 / 645 -- Section 1001 <br> Instructor: Colin Grudzien<br>

## Instructions:
We will work through the following series of activities as a group and hold small group work and discussions in Zoom Breakout Rooms.  Follow the instructions in each sub-section when the instructor assigns you to a breakout room.

## Activities:

### Activity 1: more practice with subsetting data

#### Question 1:

Given the following code:
```{r eval=FALSE}
x <- c(5.4, 6.2, 7.1, 4.8, 7.5)
names(x) <- c('a', 'b', 'c', 'd', 'e')
print(x)
```

Come up with at least 2 different commands that will produce the following output:
```{r eval=FALSE}
x[2:4]
```

After you find 2 different commands, compare notes with your peers. Did you have different strategies?

##### Solution question 1
```{r eval=FALSE}
x[2:4]
```
```{r eval=FALSE}
x[-c(1,5)]
```
```{r eval=FALSE}
x[c(2,3,4)]
```

#### Question 2:

Given the following code:

```{r eval=FALSE}
x <- c(5.4, 6.2, 7.1, 4.8, 7.5)
names(x) <- c('a', 'b', 'c', 'd', 'e')
print(x)
```

Write a subsetting command to return the values in x that are greater than 4 and less than 7.

##### Solution to question 2:
```{r eval=FALSE}
x_subset <- x[x<7 & x>4]
print(x_subset)
```

### Debrief: discuss the questions
We will discuss the questions from activity 1 as a class.


### Activity 2: subsetting a dataframe

#### Question 1:

Selecting elements of a vector that match any of a list of components
is a very common data analysis task. For example, the gapminder data set
contains `country` and `continent` variables, but no information between
these two scales. Suppose we want to pull out information from southeast
Asia: how do we set up an operation to produce a logical vector that
is `TRUE` for all of the countries in southeast Asia and `FALSE` otherwise?

Suppose you have these data:
```{r eval=FALSE}
seAsia <- c("Myanmar","Thailand","Cambodia","Vietnam","Laos")
require(gapminder)
## extract the `country` column from a data frame (we'll see this later);
## convert from a factor to a character;
## and get just the non-repeated elements
countries <- unique(as.character(gapminder$country))
```

There's a wrong way (using only `==`), which will give you a warning;
a clunky way (using the logical operators `==` and `|`); and
an elegant way (using `%in%`). See whether you can come up with all three
and explain how they (don't) work.

##### Solution to question 1

The **wrong** way to do this problem is `countries==seAsia`. This
gives a warning (`"In countries == seAsia : longer object length is not a multiple of shorter object length"`) and the wrong answer (a vector of all
`FALSE` values), because none of the recycled values of `seAsia` happen
to line up correctly with matching values in `country`.

The **clunky** (but technically correct) way to do this problem is
```{r eval=FALSE}
 (countries=="Myanmar" | countries=="Thailand" |
 countries=="Cambodia" | countries == "Vietnam" | countries=="Laos")
```
(or `countries==seAsia[1] | countries==seAsia[2] | ...`). This
gives the correct values, but hopefully you can see how awkward it
is (what if we wanted to select countries from a much longer list?).

The best way to do this problem is `countries %in% seAsia`, which
is both correct and easy to type (and read).

### Debrief: discuss the questions
We will discuss the questions from activity 2 as a class.


### Activity 3: more practice with multi-dimensional indices

#### Question 1:

Given the following code:
```{r eval=FALSE}
m <- matrix(1:18, nrow=3, ncol=6)
print(m)
```

1. Which of the following commands will extract the values 11 and 14?

A. `m[2,4,2,5]`

B. `m[2:5]`

C. `m[4:5,2]`

D. `m[2,c(4,5)]`

##### Solution to question 1:


```{r error=TRUE, eval=FALSE}
m[2,4,2,5]
m[2:5]
m[4:5,2]
m[2,c(4,5)]
```

#### Question 2:
Given the following list:

```{r eval=FALSE}
xlist <- list(a = "Software Carpentry", b = 1:10, data = head(iris))
```

Using your knowledge of both list and vector subsetting, extract the number 2 from xlist.
Hint: the number 2 is contained within the "b" item in the list.

##### Solution to question 2:

```{r eval=FALSE}
xlist$b[2]
```
```{r eval=FALSE}
xlist[[2]][2]
```
```{r eval=FALSE}
xlist[["b"]][2]
```


### Debrief: discuss the questions
We will discuss the questions from activity 3 as a class.


### Activity 4: common subsetting errors

#### Question 1:

Fix each of the following common data frame subsetting errors:

1. Extract observations collected for the year 1957

   ```{r, eval=FALSE}
   gapminder[gapminder$year = 1957,]
   ```

2. Extract all columns except 1 through to 4

   ```{r, eval=FALSE}
   gapminder[,-1:4]
   ```

3. Extract the rows where the life expectancy is longer the 80 years

   ```{r, eval=FALSE}
   gapminder[gapminder$lifeExp > 80]
   ```

4. Extract the first row, and the fourth and fifth columns
  (`continent` and `lifeExp`).

   ```{r, eval=FALSE}
   gapminder[1, 4, 5]
   ```

5. Advanced: extract rows that contain information for the years 2002
   and 2007

   ```{r, eval=FALSE}
   gapminder[gapminder$year == 2002 | 2007,]
   ```

##### Solution to question 1:

Fix each of the following common data frame subsetting errors:

1. Extract observations collected for the year 1957

   ```{r, eval=FALSE}
   # gapminder[gapminder$year = 1957,]
   gapminder[gapminder$year == 1957,]
   ```

2. Extract all columns except 1 through to 4

   ```{r, eval=FALSE}
   # gapminder[,-1:4]
   gapminder[,-c(1:4)]
   ```

3. Extract the rows where the life expectancy is longer than 80 years

   ```{r, eval=FALSE}
   # gapminder[gapminder$lifeExp > 80]
   gapminder[gapminder$lifeExp > 80,]
   ```

4. Extract the first row, and the fourth and fifth columns
  (`continent` and `lifeExp`).

   ```{r, eval=FALSE}
   # gapminder[1, 4, 5]
   gapminder[1, c(4, 5)]
   ```

5. Advanced: extract rows that contain information for the years 2002
   and 2007

    ```{r, eval=FALSE}
    # gapminder[gapminder$year == 2002 | 2007,]
    gapminder[gapminder$year == 2002 | gapminder$year == 2007,]
    gapminder[gapminder$year %in% c(2002, 2007),]
    ```

#### Question 2:

1. Why does `gapminder[1:20]` return an error? How does it differ from `gapminder[1:20, ]`?


2. Create a new `data.frame` called `gapminder_small` that only contains rows 1 through 9
and 19 through 23. You can do this in one or two steps.

##### Solution to question 2:

1.  `gapminder` is a data.frame so needs to be subsetted on two dimensions. `gapminder[1:20, ]` subsets the data to give the first 20 rows and all columns.

2. 

```{r eval=FALSE}
gapminder_small <- gapminder[c(1:9, 19:23),]
```

### Debrief: discuss the questions
We will discuss the questions from activity 4 as a class.



### Activity 5: Vectorization

#### Question 1:
Make a new column in the `gapminder` data frame that
contains population in units of millions of people.
Check the head or tail of the data frame to make sure
it worked.

##### Solution to question 1
Make a new column in the `gapminder` data frame that
contains population in units of millions of people.
Check the head or tail of the data frame to make sure
it worked.

```{r eval=FALSE}
gapminder$pop_millions <- gapminder$pop / 1e6
head(gapminder)
```

#### Question 2:
Given the following matrix:

```{r eval=FALSE}
m <- matrix(1:12, nrow=3, ncol=4)
m
```

Write down what you think will happen when you run:

1. `m ^ -1`
2. `m * c(1, 0, -1)`
3. `m > c(0, 20)`
4. `m * c(1, 0, -1, 2)`

Did you get the output you expected? If not, ask a helper!

##### Solution to question 2:

Given the following matrix:

```{r eval=FALSE}
m <- matrix(1:12, nrow=3, ncol=4)
m
```


Write down what you think will happen when you run:

1. `m ^ -1`

```{r eval=FALSE}
m ^ -1
```

2. `m * c(1, 0, -1)`

```{r eval=FALSE}
m * c(1, 0, -1)
```

3. `m > c(0, 20)`

```{r eval=FALSE}
m > c(0, 20)
```

#### Question 3:

We're interested in looking at the sum of the
following sequence of fractions:

```{r, eval=FALSE}
 x = 1/(1^2) + 1/(2^2) + 1/(3^2) + ... + 1/(n^2)
```

This would be tedious to type out, and impossible for high values of
n.  Use vectorisation to compute x when n=100. What is the sum when
n=10,000?

##### Solution to question 3:

```{r eval=FALSE}
sum(1/(1:100)^2)
sum(1/(1:1e04)^2)
n <- 10000
sum(1/(1:n)^2)
```

We can also obtain the same results using a function:
```{r eval=FALSE}
inverse_sum_of_squares <- function(n) {
  sum(1/(1:n)^2)
}
inverse_sum_of_squares(100)
inverse_sum_of_squares(10000)
n <- 10000
inverse_sum_of_squares(n)
```

### Debrief: discuss the questions
We will discuss the questions from activity 5 as a class.
