# Activity 09/02/2020

## STAT 445 / 645 -- Section 1001 <br> Instructor: Colin Grudzien<br>

## Instructions:
We will work through the following series of activities as a group and hold small group work and discussions in Zoom Breakout Rooms.  Follow the instructions in each sub-section when the instructor assigns you to a breakout room.

## Activities:

### Activity 1: more practice with subsetting data

#### Question 1:

Given the following code:
```{r eval=FALSE}
x <- c(5.4, 6.2, 7.1, 4.8, 7.5)
names(x) <- c('a', 'b', 'c', 'd', 'e')
print(x)
```

Come up with at least 2 different commands that will produce the following output:
```{r eval=FALSE}
x[2:4]
```

After you find 2 different commands, compare notes with your peers. Did you have different strategies?


#### Question 2:

Given the following code:

```{r eval=FALSE}
x <- c(5.4, 6.2, 7.1, 4.8, 7.5)
names(x) <- c('a', 'b', 'c', 'd', 'e')
print(x)
```

Write a subsetting command to return the values in x that are greater than 4 and less than 7.

### Debrief: discuss the questions
We will discuss the questions from activity 1 as a class.


### Activity 2: subsetting a dataframe

#### Question 1:

Selecting elements of a vector that match any of a list of components
is a very common data analysis task. For example, the gapminder data set
contains `country` and `continent` variables, but no information between
these two scales. Suppose we want to pull out information from southeast
Asia: how do we set up an operation to produce a logical vector that
is `TRUE` for all of the countries in southeast Asia and `FALSE` otherwise?

Suppose you have these data:
```{r eval=FALSE}
seAsia <- c("Myanmar","Thailand","Cambodia","Vietnam","Laos")
require(gapminder)
## extract the `country` column from a data frame (we'll see this later);
## convert from a factor to a character;
## and get just the non-repeated elements
countries <- unique(as.character(gapminder$country))
```

There's a wrong way (using only `==`), which will give you a warning;
a clunky way (using the logical operators `==` and `|`); and
an elegant way (using `%in%`). See whether you can come up with all three
and explain how they (don't) work.


### Debrief: discuss the questions
We will discuss the questions from activity 2 as a class.


### Activity 3: more practice with multi-dimensional indices

#### Question 1:

Given the following code:
```{r eval=FALSE}
m <- matrix(1:18, nrow=3, ncol=6)
print(m)
```

1. Which of the following commands will extract the values 11 and 14?

A. `m[2,4,2,5]`

B. `m[2:5]`

C. `m[4:5,2]`

D. `m[2,c(4,5)]`


#### Question 2:
Given the following list:

```{r eval=FALSE}
xlist <- list(a = "Software Carpentry", b = 1:10, data = head(iris))
```

Using your knowledge of both list and vector subsetting, extract the number 2 from xlist.
Hint: the number 2 is contained within the "b" item in the list.



### Debrief: discuss the questions
We will discuss the questions from activity 3 as a class.


### Activity 4: common subsetting errors

#### Question 1:

Fix each of the following common data frame subsetting errors:

1. Extract observations collected for the year 1957

   ```{r, eval=FALSE}
   gapminder[gapminder$year = 1957,]
   ```

2. Extract all columns except 1 through to 4

   ```{r, eval=FALSE}
   gapminder[,-1:4]
   ```

3. Extract the rows where the life expectancy is longer the 80 years

   ```{r, eval=FALSE}
   gapminder[gapminder$lifeExp > 80]
   ```

4. Extract the first row, and the fourth and fifth columns
  (`continent` and `lifeExp`).

   ```{r, eval=FALSE}
   gapminder[1, 4, 5]
   ```

5. Advanced: extract rows that contain information for the years 2002
   and 2007

   ```{r, eval=FALSE}
   gapminder[gapminder$year == 2002 | 2007,]
   ```

#### Question 2:

1. Why does `gapminder[1:20]` return an error? How does it differ from `gapminder[1:20, ]`?


2. Create a new `data.frame` called `gapminder_small` that only contains rows 1 through 9
and 19 through 23. You can do this in one or two steps.

### Debrief: discuss the questions
We will discuss the questions from activity 4 as a class.



### Activity 5: Vectorization

#### Question 1:
Make a new column in the `gapminder` data frame that
contains population in units of millions of people.
Check the head or tail of the data frame to make sure
it worked.


#### Question 2:
Given the following matrix:

```{r eval=FALSE}
m <- matrix(1:12, nrow=3, ncol=4)
m
```

Write down what you think will happen when you run:

1. `m ^ -1`
2. `m * c(1, 0, -1)`
3. `m > c(0, 20)`
4. `m * c(1, 0, -1, 2)`

Did you get the output you expected? 


#### Question 3:

We're interested in looking at the sum of the
following sequence of fractions:

```{r, eval=FALSE}
 x = 1/(1^2) + 1/(2^2) + 1/(3^2) + ... + 1/(n^2)
```

This would be tedious to type out, and impossible for high values of
n.  Use vectorisation to compute x when n=100. What is the sum when
n=10,000?


### Debrief: discuss the questions
We will discuss the questions from activity 5 as a class.
