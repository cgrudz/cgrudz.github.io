========================================================
autosize: true
incremental: true
width: 1920
height: 1080

<div style="background-color: white; padding:40px">
<h1 style='color:black'> An introduction to programming in R -- Part 2</h1>
<h2 style='color:black'> 08/29/2019</h2>
<h2 style='color:black'>Instructions:</h2>
<p style='color:black'>Use the left and right arrow keys to navigate the presentation forward and backward respectively.  You can also use the arrows at the bottom right of the screen to navigate with a mouse.<br></p>
</div>

========================================================

<h2>Outline</h2>

* The following topics will be covered in this lecture:

 * Vectorization
 * Variables and data types
 * Dataframes
 * Factors
 * File I/O
 * Basic plotting

* These lectures are based on the materials in [R for Reproducible Scientific Analysis](https://swcarpentry.github.io/r-novice-gapminder/).

========================================================


<h2> Vectorization</h2>

* R is a vectorized language, meaning that variables and functions can have vectors as values. 

* A vector in R describes a set of values in a certain order of the <b>same data type</b>.

  * The type of data will become increasingly important as we start using vectors.
  
* A simple way to construct a vector is with the constructor function "c()"

```{r}
c(1, 3, 6)
```

========================================================

<h3> Vectorization -- continued</h3>


* The function takes an arbitrary number of elements as above, and creates a vector.

```{r}
my_variable <- c(TRUE, pi)
my_variable
```

* Notice that the output of the above expression looks different from the input --- this is because R forces vectors to have data of a single type:

```{r}
typeof(my_variable)
```

* Here, the value "TRUE" has been forced into its numeric counterpart "1".

========================================================

<h3> Vectorization -- continued</h3>

* Certain functions allow us to construct vectors automatically based on a range of values, known as a "slice"

```{r}
my_variable <- 1:5
my_variable
```

* We can make a general slice where the arguments are given as a:b and returns a vector of all integer spaced values between a and b:

```{r}
10:5
4:10
```

* This is often quite useful for extracting a subset of data from a large vector or matrix.

========================================================

<h3> Vectorization -- continued</h3>

* One additional useful construction function for vectors is the "seq()" or sequence generation function.

* This is like the slice operator ":", but with the additional argument "by"

```{r}
seq(1,10, by=0.1)
```

* Using this, we can create a vector with a range of values with an arbitrary step in between.


========================================================

<h3> Vectorization -- continued</h3>

* Using vectors will often be necessary, but it is also extremely useful to perform mathematical operations in vectors as above.

  * Vectors firstly make code more compact and easier to read for someone working on it.
  
  * Moreover, vector operations are typically faster than alternative methods of computing.
  
  * This is because the underlying "machinery" in R is faster than executing R code;
    
    * in particular, operations as above and mathematical functions have been optimized for performance.
  
* Most typically, we will furthermore be examining tabular data which is expressed most commonly as a matrix.

* A loose familiarity with matrices will be necessary in this course, but not a deep understanding of linear algebra or applied matrix theory.

* Advanced students will benefit from understanding matrix factorizations such as QR and singular value decompositions, but the R language will take care of these details in practice.

========================================================
<h2> Review of the material </h2>

* <b>Q:</b> consider the following expressions.  What is the final value of "x" and the final value of "y"?

```{r}
x <- 5
y <- 3
x <- x * y
y <- y - x
```

* <b>A:</b>

```{r}
x
y
```

========================================================
<h3> Review of the material -- continued </h3>

* <b>Q:</b> is the following expression guaranteed to be "TRUE"?

```{r results='hide'}
0 == sin(pi)
```

* <b>A:</b> not necessarily, the way that numerical values are understood by the machine is not the same as they are mathematically:

```{r}
0 == sin(pi)
```

* <b>Q:</b> what is the outcome of the following comparison, and why?

```
1 == TRUE
```

* <b>A:</b> it is TRUE, because the logical has been coerced into numeric.

```{r}
1 == TRUE
```

========================================================
<h3> Review of the material -- continued </h3>


* <b>Q:</b> consider the following expressions --- what is the final output?

```{r results='hide'}
x <- 9:25
y <- 3:4
x[y]
```

* <b>A:</b>

```{r}
x[y]
```


* <b>Q:</b> consider the following expressions --- what is the final output?

```{r results='hide'}
x <- 9:25
y <- x > 16
x[y]
```

* <b>A:</b>

```{r}
x[y]
```

========================================================
<h3>Review of material -- continued</h3>

* We have seen that we can apply mathematical operations to numerical vectors. 

* <b>Q:</b> what do you expect the output to be of the following statement?

```{r eval=FALSE}
c('red', 'blue', 'green') + 2
```

* <b>A:</b>

```{r error=TRUE}
my_vector <- c('red', 'blue', 'green') + 2
```

* R was told to add together a numerical value and a character value, for which there is no defined output with addition.

* For operations that are undefined, there will usually be an error message as the output.

========================================================

<h2>Data types</h2>

* There are 5 main types in R: 

 * double;

```{r} 
typeof(pi)
```

 * integer;

```{r}
typeof(1L)
```
 
 * complex;

```{r}
typeof(1+1i)
```

========================================================
<h3>Data types -- continued </h3>

* and non-numeric types:

 * logical 

```{r}
typeof(TRUE)
```

 
 * character

```{r}
typeof('banana')
```

* Understanding data types and the way they are coerced is important because R strictly enforces that data in a vector is of a single type.

* By keeping everything in a column the same, we can make simple assumptions about our data; 

  * if you can interpret one entry in the column as a number, then you can interpret all of them as numbers, so we donâ€™t have to check every time. 
  
* This consistency is what people mean when they talk about clean data; 

  * in the long run, strict consistency goes a long way to making our lives easier in R.


========================================================
<h2>Type coercion</h2>

* We have seen how a vector may coerce a logical value to numeric one:

```{r}
c(TRUE, pi)
```

* <b>Q:</b> what do you expect the output of the following expression to be?

```{r eval=FALSE}
c(TRUE, 'TRUE')
```

* <b>A:</b> in this case, the logical is coerced into a "character" string,

```{r}
c(TRUE, 'TRUE')
```

========================================================
<h3>Type coercion -- continued</h3>

<ul>
  <li> The coercion rules go: </li>
  <ol>
    <li> logical -> integer</li> 
    <li> integer -> numeric </li>
    <li> numeric -> complex </li>
    <li> complex -> character,</li>
  </ol>
  <li> where -> can be read as are transformed into.</li> 
  <li>You can try to force coercion against this flow using the as. functions, e.g.,</li>
</ul>

```{r}
as.numeric(c('1', '2', '3'))
```  



========================================================
<h2>Data structures</h2>

* Vectors are one type of data structure that we encounter frequently;

  * however, there are other related (and important) data structures that we will need to manipulate.

* R has an extremely developed tool for handling tabular data, such as comma separated values.

  * in R, this tool is a "dataframe".

* We will explore the functionality of dataframes with some "cat" data in some simple examples:

```{r}
cats <- data.frame(coat = c("calico", "black", "tabby"), 
                    weight = c(2.1, 5.0, 3.2), 
                    likes_string = c(1, 0, 1))
```

* Notice that the arguments of the function "data.frame()" are three expressions associating a name with a vector.


========================================================
<h3>Dataframes</h3>

* Printing the variable "cats", we see what tabular data looks like in a dataframe:

```{r}
cats
```

* The assignment of the vectors to names in the arguments assigned the column names.

* Each column consists of <b>a vector of uniform data type</b>.

* If we want to extract a named column from a dataframe, this can be done with the "$" sign and the column name:

```{r}
cats$weight
```

* Each row, on the other hand, consists of multiple measurements (of different data types) corresponding to one specific case of the data set.


========================================================
<h3>Dataframes -- continued</h3>

* We might suppose that the scale used to measure the cats' weights was off by two kgs.

* In this case, we can re-assign values into the column weight as follows:

```{r}
cats$weight
cats$weight <- cats$weight + 2
```

* We can verify that the assignment went into the column for weight in "cats",

```{r}
cats
```

========================================================
<h2>Lists </h2>

* A data structure related to vectors are <b>lists</b>.

* Lists function as containers for heterogeneous data, allowing different types:

```{r}
list_example <- list(1, "a", TRUE, 1+4i)
list_example
```

========================================================
<h3>Lists -- continued </h3>

* In the last example no type coercion has taken place; 

```{r}
typeof(list_example[[1]])
typeof(list_example[[2]])
```

  * all of the original types have been respected, but because the data is allowed to be inhomogeneous we can't use vector operations on a list.
  
```{r error=TRUE}
list_example + 2
```

* Here we see an error message because the "+" operator only knows how to operate on numeric arguments, or ones that can be coerced into one.

========================================================
<h3>Lists -- continued </h3>

* Recall our dataframe cats,

```{r}
cats
```

* We know that dataframes contain homogeneous data in each <b>column</b>, but each row may be inhomogeneous.

* <b>Q:</b>What kind of data structure do you think a dataframe is? Can it be a vector? Why or why not?

* <b>A:</b> A dataframe cannot be a vector because of coercion rules --- instead it operates as a <b>list of vectors</b>:

```{r}
typeof(cats)
typeof(cats$weight)
```

========================================================
<h2>Factors</h2>

* Consider now the vector "coat" in the dataframe:

```{r}
cats$coat
typeof(cats$coat)
as.numeric(cats$coat)
```

* <b>Q:</b> can you hypothesize what the meaning is of this data? What is a level, and why are the coats "integer"?

* <b>A:</b> R likes to treat character strings in dataframes as categorical variables;

  * in this case, the categories are "black", "calico" and "tabby";
  
  * each integer value is encoding whether the case (or row) belongs to category 1, 2 or 3, where category labels are sorted alphanumerically.

========================================================
<h2>Manipulating dataframes</h2>

* Let's suppose that we need to include more information on our cats in our analysis; 
  
  * a friend has provided ages of all the cats for us:

```{r}
age <- c(2, 3, 5)
```

* We want to combine this into our dataframe, which can be done with "cbind()"

```{r}
cats <- cbind(cats, age)
cats
```

* This function introduces the new vector as an additional column in the dataframe; 

 * the variable name is defined the column name, and we reassign the dataframe to cats recursively.

========================================================
<h3>Adding columns to dataframes</h3>


* <b>Q:</b> can you hypothesize what will be the output if we try to combine the following vector with the dataframe?

```{r eval=FALSE}
age <- c(2, 3, 5, 8, 9)
cats <- cbind(cats, age)
```

* <b>A:</b> dataframes, like matrices, need to have consistent dimensions of the data;

  * this new column is too long, so we will get an error:

```{r error=TRUE}
age <- c(2, 3, 5, 8, 9)
cats <- cbind(cats, age)
```

========================================================
<h3>Dataframe dimensions</h3>

* We can examine the dimensions of a dataframe with standard functions:

```{r}
dim(cats)
```

* In the above we see the standard, matrix style dimensions of the dataframe.

  * these can also be extracted individually with "nrow" and "ncol":

```{r}
nrow(cats)
ncol(cats)
```

========================================================
<h3>Dataframe indices</h3>

* Entries of dataframes can be accessed directly using matrix indexing:

```{r}
cats[2,4]
```

* This can also be performed with slices:
```{r}
cats[1:2, 2:3]
```

========================================================
<h3>Dataframe indices</h3>

* Additionally, we can use specialized notation for accessing an entire row or column:

```{r}
cats[,1]
cats[1,]
```

* Here, the blank in the place of the index tells R to extract the entire row or column.

========================================================
<h3>Adding rows to dataframes</h3>

* Let's suppose we have examined a new cat and we want to add a case to our dataframe:

```{r}
newRow <- list("tortoiseshell", 3.3, TRUE, 9)
cats <- rbind(cats, newRow)
cats
```

* Notice, the "NA" value in the above for the coat of the fourth cat.

  * While the row was added successfully, it produces a "Not Available", missing data entry.
  
* Factors, like other vectors, are strict in R;

  * when we attempt to add a value that is not recognized as one of the categories, R treats this as missing data.


========================================================
<h3>Adding levels to factors</h3>

* We can access the levels of a factor vector with the "levels()" function:

```{r}
levels(cats$coat)
```

* If we want to re-assign new levels to a factor, we can do so recursively

```{r}
levels(cats$coat) <- c(levels(cats$coat), "tortoiseshell")
cats <- rbind(cats, list("tortoiseshell", 3.3, TRUE, 9))
cats
```

* Notice, "tortiseshell" was now accepted as a category, but the NA value remains.

========================================================
<h3>Summarizing dataframes</h3>

* In general, we want to know if a dataframe has missing values, and what kind of variables are in it.

* Several common functions allow this, including

  * "str()" or the structure function:

```{r}
str(cats)
```

* This tells us what the dimensions are, the column names are, and what types of variables we are working with.

========================================================
<h3>Summarizing dataframes -- continued</h3>

* We can also obtain a quick statistical summary of the data with the "summary()" function:

```{r}
summary(cats)
```

* The summary furthermore tells us how many missing values are present.

========================================================
<h3>Removing rows</h3>

* We will often want to remove cases with missing data;

  * this can be performed automatically with "na.omit()"
  
```{r}
na.omit(cats)
```

========================================================
<h3>Removing rows or columns</h3>

* We can also remove rows or columns by index, using a "-"

```{r}
cats[-1,]
cats[,-1]
```


========================================================
<h2>File IO</h2>

* Basic file input/ output (IO) can be done with functions such as:

```{r}
write.csv(x = cats, file = "data/feline-data.csv", row.names = FALSE)
cats_from_file <- read.csv(file = "data/feline-data.csv")
cats_from_file
```

* In the above, we wrote the data cats to the file "feline-data.csv" in the data directory;

* CSV is a file type that R knows how to read automatically into a dataframe with the "read.csv()" function;
  
  * using the above command, we read the file into a new dataframe "cats_from_file".

========================================================
<h3>File IO -- continued</h3>

* We will suppose that we wish to analyze a new set of cat data that a friend gave us:

```
coat,   weight,     likes_string
calico, 2.1,        1
black,  5.0,        0
tabby,  3.2,        1
tabby,  2.3 or 2.4, 1
```

* Our friend was uncertain about the weight of the last cat and placed two values into the CSV.

* We suppose that this is written in the file "feline-data_v2.csv" which we will read with "read.csv()",

```{r}
cats_from_file <- read.csv(file="data/feline-data_v2.csv")
cats_from_file$weight
```

* Notice that weight looks much different than before...

========================================================
<h3>Factors -- continued</h3>

* When R read the inhomogeneous data in the weights column, it first converted the values into character type;

  * when the character vector was seen by R in a dataframe, it then converted it automatically to a factor vector.
  
* Converting characters to factors automatically can be suppressed with additional arguments:

```{r}
cats_from_file <- read.csv(file="data/feline-data_v2.csv", stringsAsFactors=FALSE)
cats_from_file$weight
```

* However, this illustrates in general how erroneously entered data can cause many issues with type conversions.

========================================================
<h2>A realistic dataframe</h2>

* Through much of the class, we will call data from different libraries in R.

* For this lesson, and the homework, we will consider the ``gapminder`` data.

  * We start by importing this from R:
  
```{r}
require(gapminder)
```

* When we start looking at new data, best practice is to start interrogating it to see the data types, the number of cases and the different variables in each case:

```{r}
str(gapminder)
```

========================================================
<h3>A realistic dataframe -- continued</h3>

* We will also usually benefit from the summary:

```{r}
summary(gapminder)
```

========================================================
<h3>A realistic dataframe -- continued</h3>

* We also often benefit from looking at a sub-slice of the data to "feel" what kind of data we are working with.

* This is commonly done with the ``head()`` function;

  * this will extract the leading rows of the dataframe for examination:

```{r}
head(gapminder)
```

========================================================
<h3>A realistic dataframe -- continued</h3>


* Similarly, we can use the ``tail()`` function to examine the trailing rows:

```{r}
tail(gapminder)
```

========================================================
<h3>Extracting sub-sets of data</h3>

*  We might be interested in a particular country, let's say India;

  * we can, for example, make a sub-dataframe based on the cases corresponding to India alone:
  
```{r}
india_index <- gapminder$country == "India"
```

* In the above, we have constructed a logical vector for the purpose of indexing the <b>rows</b> which correspond to India.

  * Any row which contains the factor level ``India`` in the ``country`` factor vector will correspond to a ``TRUE`` in the logical vector ``india_index``.
  
  * Any row which does not contain the factor level ``India`` will respectively correspond to a ``FALSE``.

========================================================
<h3>A realistic dataframe -- continued</h3>

* Here, we will extract the India data based on the logical indexing and examine the sub-dataframe:

```{r}
india_dataframe <- gapminder[india_index, ]
head(india_dataframe)
```

========================================================
<h2>Basic plotting</h2>

* R has several different kinds of plotting commands and libraries;

  * for simple plots, intended as exploratory analysis, we often will use the "base" R plotting.
  
* For more advanced control and formatting, we will typically use a more sophisticated library, such as ``ggplot2``;

  * learning to use advanced plotting will be in the homework assignment.
  
========================================================
<h3>Basic plotting -- continued</h3>


* If we want to create a quick exploratory "x-y" plot of some relationship, this can be done with the ``plot()`` function.

* For example, we will plot the change of life expectancy over time in India:

```{r fig.width=24, fig.height=8}
plot(india_dataframe$year, india_dataframe$lifeExp) 
```
  
========================================================
<h3>Basic plotting -- continued</h3>

* In the last command, we can adjust labels and plot sizes with additional arguments in the plot function;
  
  * these arguments and "keywords" can be found in the help file for plot, using ``?plot``.

```{r fig.width=24, fig.height=8}
par(mai=c(1.5,1.5,.5,.5), mgp=c(3,0,0))
plot(india_dataframe$year, india_dataframe$lifeExp, cex=3, cex.lab=3, cex.axis=2) 
```
  
========================================================
<h2>For next time</h2>

* We will begin doing math next time.

  * The first homework will be to practice programming skills discussed this week.
  
  * If you need additional practice, continue the lessons in Software Carpentry on your own.
  
  * You will have some time to learn additional programming skills before we start modeling in the homework.
  
  * We will start with simple examples and theory for understanding fundamentals;
  
  * once we have established the fundamentals, we will begin more realistic practice with the tools as discussed this week.